/**
 * A simple row, column Position abstraction
 */

class Position
	val row:Int
	val col:Int
	class fun make(r:Int, c:Int):Position =
		new
			row = r
			col = c

// Test code
// printInteger(Position.make(1,2).row)


/**
 * A simple Position list abstraction, with functional abstractions for computation
 */

type PositionList
	fun isEmpty():Bool
	fun forEach(f:Position -> Unit):Unit

	// hack: fix associativity
	fun reduce(identity:Bool, f:Position -> Bool, c:Bool -> (Bool -> Bool)):Bool

class Cons
	implements PositionList // do we want this to be indented?
	
	var v:Position
	var n:PositionList
	
	fun isEmpty():Bool = false
	fun forEach(f:Position -> Unit):Unit =
		f(this.v)
		this.n.forEach(f)
	fun reduce(identity:Bool, f:Position -> Bool, c:Bool -> (Bool -> Bool)):Bool =
		val nextResult : Bool = this.n.reduce(identity,f,c)
		c(f(this.v))(nextResult)
	
	class fun make(value:Position,next:PositionList):PositionList =
		new
			v = value
			n = next
	
class Nil
	implements PositionList
	
	fun isEmpty():Bool = true
	fun forEach(f:Position -> Unit):Unit = ()
	fun reduce(identity:Bool, f:Position -> Bool, c:Bool -> (Bool -> Bool)):Bool = identity
	class fun make():PositionList = new
	
val nil : PositionList = Nil.make()
	
fun not(b:Bool):Bool =
	if b
		then
			false
		else
			true
	
fun isSafe(board:PositionList, row:Int, col:Int):Bool =
	fun isSafeWith(pos:Position):Bool =
		val delta : Int = col - pos.col
		val isUnsafe : Bool = (row == pos.row) || (row == pos.row + delta) || (row == pos.row - delta)
		not(isUnsafe)
		
	// TODO: refactor to a meth, and use a product type for the argument instead of currying
	// TODO: just use && as the function
	val combine : Bool -> (Bool -> Bool) =
		fn b1:Bool => fn b2:Bool => b1 && b2
		
	board.reduce(true, isSafeWith, combine)
	
// Test code
// val cornerBoard : PositionList = Cons.make(Position.make(0,0),nil)
// printBoolean(isSafe(nil, 5, 5))
// printBoolean(isSafe(cornerBoard, 5, 5))
// printBoolean(isSafe(cornerBoard, 4, 5))
	
class Range
	val low : Int
	val high : Int
	
	fun reduce(identity:Int, f:Int -> Int, c:Int -> (Int -> Int)):Int =
		fun helper(x:Int):Int =
			if x == this.high
				then
					identity
				else
					val nextAnswer : Int = helper(x+1)
					c(nextAnswer)(f(x))
		helper(this.low)
		
	class fun make(l:Int,h:Int):Range =
		new
			low = l
			high = h
	
fun place(board:PositionList, col:Int, maxCol:Int):Int
	if (col == maxCol)
		then
			1
		else
			fun rowTest(row:Int):Int =
				if isSafe(board, row, col)
					then
						val pos:Position = Position.make(row, col)
						place(Cons.make(pos,board), col+1, maxCol)
					else
						0
			Range.make(0,maxCol).reduce(0,rowTest,fn x:Int=>fn y:Int=>x+y)
		
fun nQueens(size:Int):Int =
	place(nil,0,size)
	
nQueens(11)
	
